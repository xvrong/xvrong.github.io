---
layout:       post
title:        网络流学习笔记
subtitle:     算法学习1
date:         2021-01-10 20:09:45
author:       xv_rong
header-img:   img/pixiv56586185.jpg
catalog:      true
tags:
  - ACM - 网络流 - 算法
---

> 假期ACM提升计划start！！！

# 问题情景

如图，网络中有两台计算机$s$和$t$和其他若干计算机，计算机之间用光缆连接，每条光缆都有一个最大传输速率。现在想从$s$传输数据到$t$，问$s$到$t$最大传输率是多少。

# 网络流基础知识

## 网络流基础概念

> 网络流的研究对象为**有向图**。

### 流相关

有源点$s$和汇点$t$，$s$能无限的提供流量，$s$出发的流量最终回汇聚到$t$，且所有的边的边权都为正的有向图称为**容量网络**。上图的计算机网络就是一个容量网络。有向图中的边称为**弧**，边权称为**弧的容量**。弧上实际的流量被称为**弧的流量**。所有这些弧的流量所组成的集合叫做**网络流**。

每条弧上的流量不超过其容量，且除了源点和汇点之外，每个点的流出的流量和流入的流量相等的网络流叫做**可行流**。~~由物理知识可知，研究可行流比较有意义~~。在一个可行流中，源点流出的流量总和称为**可行流的流量**。所谓的**最大流**就是最大的可行流的流量。

对于顶点序列$(s, U_1, U_2,..., U_n, t)$，这样一个顶点序列，如果相邻顶点间均有一条边，**（无论正向还是逆向）**,这个序列就被称为一条*链*，和链方向一致的弧称为*前向弧*，相反的弧称为**后向弧**。如图

对于一条可行流中的一条链来说，满足

1. 所有前向弧的流量小于其容量
2. 所有后向弧的流量大于0

就称它为一条**增广路**。

**显然对于一条增广路来说，增加其上正向弧的流量或减小反向弧的流量，就会让可行流的流量增大。**

### 割相关

$割$是一个边的集合，如果将这个集合中的边删去，图就分为两个联通分量$S$和$T$。如果$sS$，$TT$，就称这是一个*$S-T$割*。

**割的容量**为从$S$向$T$所有的连边的容量之和。就是任意$S$中的顶点到$T$中顶点的**前向弧的容量之和**。容量最小的割就是**最小割**。
**割的流量**为任意$S$中的顶点到$T$中顶点的**所有的前向弧的流量之和减去所有的后向弧的流量之和**。

## 最大流最小割定理

### 定理内容

**最大流的流量=最小割的容量**

### 证明

命题一：对于可行流的任意一个割，割的流量=可行流的流量。

> 证明：
>
> 可行流中，对于任何一个非s和t的顶点，有流入这个顶点的流量=流出这个顶点的流量。对于S-T割中S集合中的所有非s的顶点，则有**所有的前向弧的流量之和减去所有的后向弧的流量之和**为0，再考虑原点s，则**所有的前向弧的流之和减去所有的后向弧的流量之和**=s流出的流量总和，也就是可行流的流量。而根据割的流量定义，也恰好就是一个割的流量。

命题二：可行流的流量一定小于等于任何一个割的容量。

>由命题一可知，可行流的流量=割的流量$\leqslant$割的容量。

命题三：对于可行流$G$，设其流量为$f$，如下三个命题等价：

1. 存在一个割使得割的容量$c=f$。
2. $f$是最大流。
3. $G$中不存在任何增广路。

> 证明：
>
> $1 \Rightarrow 2$ 
>
> 由命题一可知，可行流的流量的最大可能值就为割的容量的最小值，如果存在一个割使$c=f$，则$f$一定是最大流量，也就是最大流。
>
> $2 \Rightarrow 3$ 
>
> 证明其逆否命题，$G$中存在增广路，则$f$不是最大流。
>
> 若$G$中存在真广路，由增广路的定义可知，$f$的流量一定可以增大，则$f$不是最大流。
>
> $3 \Rightarrow 1$ 
>
> $G$中不存在增广路，意味着从$s$到$t$的所有链中一定存在饱和前向弧（流量=容量）或者零流后向弧（流量=0），说明可行流$G$中，源点不通过饱和前向弧或者零后向弧无法达汇点。我们可以构造这样一个点集$S$，为可行流G中经过非饱和前向弧和非零后向弧就可以到达的顶点。其余顶点放入点集$T$中。则$S$和$T$之间的弧一定没有非饱和前向弧或者非零后向弧，即所有$S$和$T$之间的弧，一定要都是饱和前向弧或者零后向弧，则$S$和$T$所对应的$S-T$割有:$$割的流量=前向弧的流量-后向弧的流量=前向弧的容量-0=前向弧容量=割的容量$$。
>
> 则由命题一可知，可行流的流量=割的流量$\leqslant$割的容量=割的流量。即存在一个割使得割的容量$c=f$。

由上面的讨论我们就可以证明最大流=最小割。同时我们也有了一种找到最大流的方法，就是不断调整可行流的流量使可行流中不存在增广路。这时可行流的流量就是最大流。

# 算法

## Ford-Fulkerson算法

### 算法介绍

（wiki百科）只要有一条从源点（开始节点）到汇点（结束节点）的路径，在路径的所有边上都有可用容量，就沿着这条路径发送一个流，流量由路径上的最小容量限制。 然后再找到另一条路径，一直到网络中不存在这种路径为止。 一条有可用容量的路径被称为一条增广路径。

步骤：

1. dfs搜索出一条增广路。
2. 增广路上每条弧都用这条弧的容量反向建边。
3. 重复执行1，直到没有增广路为止。

### 模板

```c++
// 洛谷P3376 T了两个点，玄学复杂度。。。
#include <bits/stdc++.h>
#define fast_io                                                                                                                \
    ios::sync_with_stdio(false);                                                                                               \
    cin.tie(0);                                                                                                                \
    cout.tie(0)
using namespace std;
using ll = long long;
using P = pair<int, int>;
const int inf = 0x3f3f3f3f;
const ll llinf = 0x3f3f3f3f3f3f3f3fll;
const int onf = 0xcfcfcfcf;
const int N = (int)1e5 + 5;
const int M = (int)1e5 + 5;
const int mod = (int)1e9 + 7;
const double esp = 1e-8;
//------------天佑AC------------------

int head[N]; // n为点个数
int cnt = 0;
struct Edge {
    int v;
    ll w;
    int rev;
};
void add(vector<vector<Edge>> &g, vector<vector<int>> &flag, int u, int v, int w) {
    if (flag[u][v] == -1) {
        g[u].push_back((Edge){v, w, g[v].size()});
        g[v].push_back((Edge){u, 0, g[u].size() - 1});
        flag[u][v] = g[u].size() - 1;
        flag[v][u] = g[v].size() - 1;
    } else {
        g[u][flag[u][v]].w += w;
    }
}
ll dfs(vector<vector<Edge>> &g, vector<bool> &vis, int u, int t, ll f) {
    if (u == t)
        return f;
    vis[u] = true;
    for (int i = 0; i < g[u].size(); ++i) {
        Edge &e = g[u][i];
        if (!vis[e.v] && e.w > 0) {
            ll d = dfs(g, vis, e.v, t, min(f, e.w));
            if (d > 0) {
                e.w -= d;
                g[e.v][e.rev].w += d;
                return d;
            }
        }
    }
    return 0;
}
ll Ford_Fulkerson(vector<vector<Edge>> &g, int s, int t) {
    ll flow = 0, f = 0;
    do {
        vector<bool> vis(g.size());
        f = dfs(g, vis, s, t, llinf);
        flow += f;
    } while (f != 0);
    return flow;
}
int main() {
    fast_io;
    int n, m, s, t;
    cin >> n >> m >> s >> t;
    vector<vector<Edge>> g(n + 1);
    vector<vector<int>> flag(n + 1, vector<int>(n + 1, -1));
    for (int u, v, w, i = 0; i < m; ++i) {
        cin >> u >> v >> w;
        add(g, flag, u, v, w);
    }
    cout << Ford_Fulkerson(g, s, t) << endl;
    return 0;
}int head[N]; // n为点个数
int cnt = 0;
struct Edge {
    int v, w;
    int nxt;
} edge[M]; // m为边个数
void init() {
	memset(head, -1, sizeof(head));
    cnt = 0;
}
void add(int u, int v, int w) {
    edge[cnt].w = w;
    edge[cnt].v = v;
    edge[cnt].nxt = head[u];
    head[u] = cnt++;
}
```

### 复杂度分析

时间复杂度：$O(F|E|)$

>  每次流量可能增加1，最多进行F次深搜，复杂度和$F$有关，容易被卡

# 写在最后

> [感谢syddf_shadow大大的证明](https://blog.csdn.net/yjr3426619/article/details/82715779)
>
> 部分内容来自《挑战程序设计竞赛》。





